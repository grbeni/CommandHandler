package inc

import "http://www.yakindu.org/sct/sexec/1.0.0"
import "http://www.yakindu.org/base/types/2.0.0"
import "http://www.yakindu.org/sct/statechart/SGen"
import "http://www.yakindu.org/sct/sgraph/2.0.0"
import "http://www.yakindu.org/base/base/2.0.0"
import "http://www.yakindu.org/sct/statechart/SText"
import epackage "http://www.yakindu.org/base/expressions/Expressions"


// Beni patternje
pattern SatechartToStateName(stateChart : Statechart, name, state : State, region : Region) {
	Statechart.regions.vertices(stateChart, state);
	State.name(state, name);
	State.parentRegion(state, region);
}


// Beni patternje
pattern getEntry(region : Region, entry : Entry, name) {
	Region.vertices.name(region, name);
	Entry.name(entry, name);
}

// Változók lekérése
pattern variableDefinitions(variable : VariableDefinition, name, isReadonly, type) {
	VariableDefinition.name(variable, name);
	VariableDefinition.readonly(variable, isReadonly);
	VariableDefinition.type(variable, type);
}

// Region-ök lekérése Entry-jükkel
pattern entryOfRegions(regionName, region : Region, entry : Entry, transition : Transition, state : Vertex) {
	Region.name(region, regionName);
	Entry.parentRegion(entry, region);
	Entry.outgoingTransitions(entry, transition);
	Vertex.incomingTransitions(state, transition);
}

// Legfelsõ szintû regionök lekérése
pattern topRegions(region : Region) {
	Statechart.regions(_statechart, region);	
}

// State-ek lekérése a parentRegionjével és nevével
pattern states(state : State, parentRegion : Region, name) {
	State.parentRegion(state, parentRegion);
	State.name(state, name);
}

// Transitionök lekérése source-ukkal és targetjükkel
pattern sourceAndTargetOfTransitions(transition : Transition, source : Vertex, target : Vertex) {
	Transition.source(transition, source);
	Transition.target(transition, target);
}

// Choice-ok lekérése parentRegionükkel
pattern choices(choice : Choice, region : Region) {
	Choice.parentRegion(choice, region);
}

// Exit node-ok lekérése a parentRegionjüket
pattern exitNodes(exit : Exit, region : Region) {
	Exit.parentRegion(exit, region);
}

// Final state-ek lekérése
pattern finalStates(finalState : FinalState, region : Region) {
	FinalState.parentRegion(finalState, region);
}

pattern finalStateEdge(incomingEdge : Transition) {
	FinalState.incomingTransitions(_finalState, incomingEdge);
}

// Összetettebb patternek, amelyeket késõbb hoztam létre

// Azonos regionben lévõ vertexek közötti transitionöket adja vissza
pattern edgesInSameRegion(transition : Transition, source : Vertex, target : Vertex, parentRegion : Region) {
	Transition.source(transition, source);
	Transition.target(transition, target);
	Transition.source.parentRegion(transition, parentRegion);
	Transition.target.parentRegion(transition, parentRegion);
}

// Különbözõ regionben lévõ vertexek közötti transitionöket adja vissza
pattern edgesAcrossRegions(transition : Transition, source : Vertex, target : Vertex) {
	Transition.source(transition, source);
	Transition.target(transition, target);
	Transition.source.parentRegion(transition, parentRegion1);
	Transition.target.parentRegion(transition, parentRegion2);	
	parentRegion1 != parentRegion2;
}

// Composite state-eket adja vissza
pattern compositeStateCount(compositeState : State) {
	State.regions(compositeState, _region);
}

// Composite state-eket adja vissza
pattern compositeStates(compositeState : State, parentRegion : Region, name) {
	State.regions(compositeState, _region);
	State.name(compositeState, name);
	State.parentRegion(compositeState, parentRegion);
}

// Composite state-ek alrégióit adja vissza
pattern regionsOfCompositeStates(compositeState : State, parentRegion : Region, name, subregion : Region) {
	find compositeStates(compositeState, parentRegion, name);
	State.regions(compositeState, subregion);
}

// Egy Region Vertex-eit adja vissza
pattern verticesOfRegions(region : Region, vertex : Vertex) {
	Region.vertices(region, vertex);
}

// A ReactionEffectek Expressionjeit adja vissza
pattern reactionEffectToExpression(reactionEffect : ReactionEffect, expression : Expression) {
	ReactionEffect.actions(reactionEffect, expression);
}

// Needed for the next pattern, so the raising events are not handled as updates
pattern eventRaisingExpressions(expression : EventRaisingExpression) {
	EventRaisingExpression(expression);
}

// Az ReactionEffecttel rendelkezõ transitionöket aadja vissza
pattern edgesWithEffect(transition : Transition, effect : ReactionEffect, expression : Expression) {
	Transition.effect(transition, effect);
	ReactionEffect(effect);
	find reactionEffectToExpression(effect, expression);
	neg find eventRaisingExpressions(expression);
}

// Az EntryEventtel rendelkezõ state-ek effectjét adja vissza
pattern statesWithEntryEvent(state : State, parentRegion : Region, expression : Expression) {
	State.parentRegion(state, parentRegion);
	State.localReactions(state, reaction);
	Reaction.trigger(reaction, trigger);
	ReactionTrigger.triggers(trigger, entryEvent);
	EntryEvent(entryEvent);
	Reaction.effect(reaction, effect);
	find reactionEffectToExpression(effect, expression);
}

// Az ExitEventtel rendelkezõ state-ek effectjét adja vissza
pattern statesWithExitEvent(state : State, transition : Transition, expression : Expression) {
	State.outgoingTransitions(state, transition);
	State.localReactions(state, reaction);
	Reaction.trigger(reaction, trigger);
	ReactionTrigger.triggers(trigger, exitEvent);
	ExitEvent(exitEvent);
	Reaction.effect(reaction, effect);
	find reactionEffectToExpression(effect, expression);
}

// Az ExitEventtel rendelkezõ, de kimenõ éllel nem feltétlenül rendelkezõ state-ek effectjét adja vissza
pattern statesWithExitEventWithoutOutgoingTransition(state : State, expression : Expression) {
	State.localReactions(state, reaction);
	Reaction.trigger(reaction, trigger);
	ReactionTrigger.triggers(trigger, exitEvent);
	ExitEvent(exitEvent);
	Reaction.effect(reaction, effect);
	find reactionEffectToExpression(effect, expression);
}

// Guardok expression-jeit adja vissza
pattern guardToExpression(guard : Guard, expression : Expression) {
	Guard.expression(guard, expression);
}

pattern guardWithEventValue(expression : LogicalRelationExpression, name) {
	Guard.expression(guard, expression);
	LogicalRelationExpression.leftOperand(expression, left);
	FeatureCall.feature(left, feature);
	EventDefinition.name(feature, name);
}

// A guarddal rendelkezõ transitionöket adja vissza
pattern edgesWithGuard(transition : Transition, guard : Guard, expression : Expression) {
	Transition.trigger(transition, trigger);
	ReactionTrigger.guard(trigger, guard);
	find guardToExpression(guard, expression);
}

// Raising eventtel rendelkezõ edge-eket adja meg
pattern edgesWithRaisingEvent(transition : Transition, element : EventDefinition, name){
	Transition.effect(transition, effect);	
	Reaction.effect(_reaction, effect);
	find reactionEffectToExpression(effect, raiseExpression);
	EventRaisingExpression.event(raiseExpression, event);
	ElementReferenceExpression.reference(event, element);
	EventDefinition.name(element, name);
}

// Returns raising event elements that have assignment expression
pattern raisingExpressionsWithAssignment(element : EventDefinition, value : Expression, name) {
	EventRaisingExpression.event(raiseExpression, event);
	ElementReferenceExpression.reference(event, element);
	EventDefinition.name(element, name);
	EventRaisingExpression.value(raiseExpression, value);
}

// Raising Event célpontjai
pattern edgesWithTriggerElementReference(transition : Transition, element : EventDefinition, name){
	Transition.trigger(transition, reactionTrigger);
	ReactionTrigger.triggers(reactionTrigger, trigger);
	RegularEventSpec.event(trigger, event);
	ElementReferenceExpression.reference(event, element);
	EventDefinition.name(element, name);
}

// Adott composite state regionjeiben az entry node-ból kimenõ éleket adja vissza
pattern edgesFromEntryOfParallelRegions(compositeState : State, transition : Transition) {
	State.regions(compositeState, region);
	Region.vertices(region, entry);
	Entry.outgoingTransitions(entry, transition);
}

// Azokat az éleket adja vissza, amelyeknek van idõre vonatkozó triggere (after .. sec)
pattern edgesWithTimeTrigger(incomingTransition : Transition, triggerTransition : Transition, value : Expression, source : Vertex, parentRegion : Region) {
	Vertex.incomingTransitions(source, incomingTransition);
	Vertex.parentRegion(source, parentRegion);
	Transition.source(triggerTransition, source);
	Transition.trigger(triggerTransition, reactionTrigger);
	ReactionTrigger.triggers(reactionTrigger, trigger);
	TimeEventSpec.value(trigger, value);
}

pattern eventsWithType(event : EventDefinition, name) {
	EventDefinition.name(event, name);
	EventDefinition.type(event, _type);
}

// Leszedi az in eventket
pattern inEvents(inEvent : EventDefinition, name) {
	EventDefinition.direction(inEvent, ::IN);
	EventDefinition.name(inEvent, name);
}

// Triggerrel rendelkezõ transitionöket szedi le
pattern triggerOfTransition(transition : Transition, parentRegion : Region, feature : EventDefinition, triggerName) {
	Transition.source.parentRegion(transition, parentRegion);
	Transition.trigger(transition, trigger);
	ReactionTrigger.triggers(trigger, aTrigger);
	RegularEventSpec.event(aTrigger, event);
	FeatureCall.feature(event, feature);
	EventDefinition.name(feature, triggerName);
}

// Leszedi a beadható értékeket
pattern inValues(interface : InterfaceScope, variable : VariableDefinition, name, initialValue : Expression) {
	InterfaceScope.name(interface, "IntegerValues");
	InterfaceScope.declarations(interface, variable);
	VariableDefinition.readonly(variable, true);
	VariableDefinition.name(variable, name);
	VariableDefinition.initialValue(variable, initialValue);
}

pattern transitionWithTrigger(transition : Transition) {
	Transition.trigger(transition, _trigger);
}

// Leszedi az exitNode-ok szinkornizációjához szükséges objektumokat
pattern exitNodeSync(exitNode : Exit, parentState : State, parentRegion : Region, exitNodeTransition : Transition, defaultTransition : Transition) {
	Exit.incomingTransitions(exitNode, exitNodeTransition);
	Exit.parentRegion.composite(exitNode, parentState);
	Exit.parentRegion(exitNode, parentRegion);
	State.outgoingTransitions(parentState, defaultTransition);
	neg find transitionWithTrigger(defaultTransition);
}